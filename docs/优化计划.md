# 《星穹铁道剧情复现计划》优化计划

**文档版本**：v1.1
**创建日期**：2026-02-05
**状态**：规划中
**目的**：记录 Phase 2-3 的优化项和技术债务

---

## 一、文档说明

本文档记录在 Phase 1 开发过程中，为了快速验证核心功能而暂时搁置的优化项、技术债务和 Phase 2-3 的扩展功能。

**优先级定义**：
- **P0**：Phase 2 必须实现
- **P1**：Phase 2 推荐实现
- **P2**：Phase 3 实现
- **P3**：Phase 3 后可选

---

## 二、LLM 接口优化

### 2.1 流式输出（Phase 2-3）

**优先级**：P1

**需求**：
- 支持流式生成文本，提升用户体验
- 实时显示角色对话，而不是等待完整响应

**实现方案**：
```typescript
export interface LLMProvider {
  // 新增方法
  generateStream?(
    messages: LLMMessage[],
    options?: LLMGenerateOptions
  ): AsyncIterable<LLMStreamChunk>;
}

export interface LLMStreamChunk {
  content: string;
  finishReason?: 'stop' | 'length' | 'content_filter';
}
```

**影响范围**：
- LLM Provider 接口
- CharacterAgent
- CLI 表现层（需要支持流式显示）

---

### 2.2 函数调用（Phase 2-3）

**优先级**：P2

**需求**：
- 支持 LLM 函数调用（Function Calling）
- 用于结构化输出（如角色行动、状态变化）

**实现方案**：
```typescript
export interface LLMProvider {
  // 新增方法
  generateWithFunctions?(
    messages: LLMMessage[],
    functions: LLMFunction[],
    options?: LLMGenerateOptions
  ): Promise<LLMFunctionCallResponse>;
}

export interface LLMFunction {
  name: string;
  description: string;
  parameters: Record<string, any>; // JSON Schema
}

export interface LLMFunctionCallResponse {
  functionCall?: {
    name: string;
    arguments: string; // JSON string
  };
  content?: string;
  usage?: LLMUsage;
}
```

**应用场景**：
- 角色行动决策（如「移动到场景 X」「使用道具 Y」）
- 状态变化建议（如「信任度应该增加」）

---

### 2.3 错误处理和重试机制（Phase 2）

**优先级**：P0

**需求**：
- LLM API 调用失败时自动重试
- 超时处理
- 降级策略（可选）

**实现方案**：
```typescript
export class LLMProviderWithRetry implements LLMProvider {
  constructor(
    private provider: LLMProvider,
    private retryConfig: RetryConfig
  ) {}

  async generate(
    messages: LLMMessage[],
    options?: LLMGenerateOptions
  ): Promise<LLMGenerateResponse> {
    let lastError: Error;

    for (let attempt = 0; attempt < this.retryConfig.maxRetries; attempt++) {
      try {
        return await this.provider.generate(messages, options);
      } catch (error) {
        lastError = error;

        // 判断是否可重试
        if (!this.isRetryableError(error)) {
          throw error;
        }

        // 等待后重试
        await this.delay(this.retryConfig.retryDelay * Math.pow(2, attempt));
      }
    }

    throw lastError;
  }

  private isRetryableError(error: any): boolean {
    // 网络错误、超时、429 等可重试
    return error.code === 'ETIMEDOUT' ||
           error.status === 429 ||
           error.status >= 500;
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

**配置**：
```yaml
# config/llm.yaml
retry:
  max_retries: 3
  retry_delay: 1000  # ms
  timeout: 30000     # ms
```

---

## 三、行为模型优化

### 3.1 动态情绪状态（Phase 2）

**优先级**：P1

**需求**：
- 人物具有动态情绪状态（joy, sadness, anger, fear, surprise, disgust）
- 情绪随事件变化
- 情绪影响行为倾向和对话风格

**实现方案**：
```typescript
export const EmotionalStateSchema = z.object({
  joy: z.number().min(0).max(1),
  sadness: z.number().min(0).max(1),
  anger: z.number().min(0).max(1),
  fear: z.number().min(0).max(1),
  surprise: z.number().min(0).max(1),
  disgust: z.number().min(0).max(1)
});

export const CharacterSchema = z.object({
  // ... 其他字段
  personality: z.object({
    traits: BigFiveTraitsSchema,
    values: ValuesSchema,
    behavior_tendencies: BehaviorTendenciesSchema.optional(),

    // Phase 2 新增
    emotional_state: EmotionalStateSchema.optional()
  })
});
```

**情绪衰减机制**：
- 情绪随时间衰减（如每回合衰减 10%）
- 情绪影响行为倾向（如高 anger 时 impulsivity 增加）

---

### 3.2 动态动机强度（Phase 2）

**优先级**：P1

**需求**：
- 人物具有动态动机（curiosity, safety, belonging, achievement）
- 动机随情境变化
- 动机影响行为选择

**实现方案**：
```typescript
export const MotivationStateSchema = z.object({
  curiosity: z.number().min(0).max(1),      // 好奇心
  safety: z.number().min(0).max(1),         // 安全需求
  belonging: z.number().min(0).max(1),      // 归属需求
  achievement: z.number().min(0).max(1)     // 成就需求
});
```

---

### 3.3 认知风格（Phase 3）

**优先级**：P2

**需求**：
- 认知风格（analytical, intuitive, systematic, holistic）
- 决策风格（rational, emotional, impulsive, deliberate）
- 认知偏差（optimism_bias, confirmation_bias）

**实现方案**：
```typescript
export const CognitiveStyleSchema = z.object({
  thinking_style: z.object({
    analytical: z.number().min(0).max(1),
    intuitive: z.number().min(0).max(1),
    systematic: z.number().min(0).max(1),
    holistic: z.number().min(0).max(1)
  }),
  decision_making: z.object({
    rational: z.number().min(0).max(1),
    emotional: z.number().min(0).max(1),
    impulsive: z.number().min(0).max(1),
    deliberate: z.number().min(0).max(1)
  }),
  biases: z.object({
    optimism_bias: z.number().min(0).max(1),
    confirmation_bias: z.number().min(0).max(1)
  }).optional()
});
```

---

### 3.4 行为演化与学习（Phase 3）

**优先级**：P3

**需求**：
- 人物的行为模型可以随经历演化
- 学习机制（如重复经历某类事件后，行为倾向发生变化）

**实现方案**：
- 记录人物的行为历史
- 根据行为结果调整行为倾向
- 可配置的学习率

---

## 四、存储层优化

### 4.1 数据库存储（Phase 3）

**优先级**：P1

**需求**：
- 当人物数量增多（5+ 个角色）时，单文件存储性能下降
- 需要支持复杂查询（如按人物 ID/主题标签查询锚点）

**实现方案**：
```typescript
export interface StorageAdapter {
  // 会话状态
  saveSessionState(sessionId: string, state: SessionState): Promise<void>;
  loadSessionState(sessionId: string): Promise<SessionState>;

  // 快照
  saveSnapshot(sessionId: string, snapshotId: string, state: SessionState): Promise<void>;
  loadSnapshot(sessionId: string, snapshotId: string): Promise<SessionState>;

  // 锚点
  saveAnchor(storylineId: string, nodeId: string, anchor: Anchor): Promise<void>;
  loadAnchor(storylineId: string, nodeId: string): Promise<Anchor>;
  queryAnchors(query: AnchorQuery): Promise<Anchor[]>;
}

// 实现类
export class SQLiteStorage implements StorageAdapter {
  // 使用 better-sqlite3
}

export class MongoDBStorage implements StorageAdapter {
  // 使用 MongoDB
}
```

**迁移策略**：
- Phase 1-2 使用 JSONFileStorage
- Phase 3 提供迁移工具（JSON → SQLite/MongoDB）
- 通过 DI 容器切换实现

---

### 4.2 增量快照（Phase 3）

**优先级**：P2

**需求**：
- 当快照数量很多（50+ 个）时，存储空间占用大
- 快照之间有大量重复数据

**实现方案**：
```typescript
export interface Snapshot {
  snapshotId: string;
  basedOn?: string;  // 基于哪个快照（增量快照）
  timestamp: number;

  // 完整快照
  fullState?: SessionState;

  // 增量快照（仅差异）
  delta?: {
    [path: string]: any;  // 如 "characters.character_march7.state.relationships.character_stelle.trust": 0.85
  };
}
```

**优点**：
- 节省存储空间（80%+ 空间节省）
- 快照创建更快

**缺点**：
- 恢复快照需要计算（base + delta）
- 实现复杂

---

## 五、性能优化

### 5.1 LLM 并发调用（Phase 2）

**优先级**：P0

**需求**：
- 多 Agent 场景下，并发调用 LLM
- 减少总响应时间

**实现方案**：
```typescript
export class StoryOrchestrator {
  async processMultipleAgents(
    characterIds: string[],
    context: Context
  ): Promise<AgentResponse[]> {
    // 并发调用
    const promises = characterIds.map(id =>
      this.characterAgent.generateResponse(id, context)
    );

    // 等待所有完成
    const results = await Promise.allSettled(promises);

    // 处理结果
    return results.map((result, index) => {
      if (result.status === 'fulfilled') {
        return result.value;
      } else {
        console.error(`Agent ${characterIds[index]} failed:`, result.reason);
        return null;
      }
    }).filter(Boolean);
  }
}
```

---

### 5.2 LLM 响应缓存（Phase 3）

**优先级**：P2

**需求**：
- 相同 Prompt 缓存结果
- 减少 API 调用次数和成本

**实现方案**：
```typescript
export class LLMProviderWithCache implements LLMProvider {
  private cache: Map<string, LLMGenerateResponse> = new Map();

  async generate(
    messages: LLMMessage[],
    options?: LLMGenerateOptions
  ): Promise<LLMGenerateResponse> {
    const cacheKey = this.getCacheKey(messages, options);

    // 检查缓存
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)!;
    }

    // 调用 LLM
    const response = await this.provider.generate(messages, options);

    // 缓存结果
    this.cache.set(cacheKey, response);

    return response;
  }

  private getCacheKey(messages: LLMMessage[], options?: LLMGenerateOptions): string {
    return JSON.stringify({ messages, options });
  }
}
```

**配置**：
```yaml
# config/llm.yaml
cache:
  enabled: true
  ttl: 3600  # 缓存 1 小时
  max_size: 1000  # 最多缓存 1000 条
```

---

### 5.3 性能监控（Phase 3）

**优先级**：P2

**需求**：
- 监控 LLM API 调用延迟
- 监控系统响应时间
- 监控 Token 使用量和成本
- 性能瓶颈识别

**实现方案**：
```typescript
export interface PerformanceMetrics {
  llmApiLatency: number;        // LLM API 延迟（ms）
  systemResponseTime: number;   // 系统响应时间（ms）
  tokenUsage: {
    prompt: number;
    completion: number;
    total: number;
  };
  cost: number;                 // 成本（USD）
}

export class PerformanceMonitor {
  private metrics: PerformanceMetrics[] = [];

  recordMetric(metric: PerformanceMetrics): void {
    this.metrics.push(metric);
  }

  getAverageLatency(): number {
    return this.metrics.reduce((sum, m) => sum + m.llmApiLatency, 0) / this.metrics.length;
  }

  getTotalCost(): number {
    return this.metrics.reduce((sum, m) => sum + m.cost, 0);
  }

  exportMetrics(): string {
    // 导出为 CSV 或 JSON
    return JSON.stringify(this.metrics, null, 2);
  }
}
```

**监控指标**：
- LLM API 平均延迟 < 2s
- 系统端到端响应时间 < 5s
- Token 使用量统计（按 Provider 分类）
- 成本统计（按日/周/月）

**可视化**：
- 可选：集成 Grafana 或简单的 Web 仪表盘
- 导出 CSV 供 Excel 分析

---

### 5.4 日志分析工具（Phase 3）

**优先级**：P2

**需求**：
- 集中化日志聚合
- 日志查询与过滤
- 错误日志告警
- 日志归档与清理

**实现方案**：
```typescript
export class LogAnalyzer {
  constructor(private logDir: string) {}

  // 查询日志
  async queryLogs(filter: LogFilter): Promise<LogEntry[]> {
    // 按时间范围、级别、模块过滤日志
  }

  // 统计错误
  async getErrorStats(timeRange: TimeRange): Promise<ErrorStats> {
    // 统计错误类型、频率
  }

  // 导出日志
  async exportLogs(filter: LogFilter, format: 'json' | 'csv'): Promise<string> {
    // 导出过滤后的日志
  }

  // 归档旧日志
  async archiveLogs(olderThan: Date): Promise<void> {
    // 压缩并归档旧日志
  }
}
```

**日志格式**：
```json
{
  "timestamp": "2026-02-05T10:30:00.000Z",
  "level": "error",
  "module": "LLMProvider",
  "message": "API call failed",
  "context": {
    "provider": "deepseek",
    "error": "ETIMEDOUT"
  }
}
```

**工具**：
- 可选：集成 ELK Stack（Elasticsearch + Logstash + Kibana）
- 或使用简单的命令行工具（grep、jq）

---

## 六、测试与质量保证

### 6.1 单元测试（Phase 2）

**优先级**：P1

**需求**：
- 关键模块有单元测试
- 测试覆盖率 > 60%

**测试框架**：
- **Jest**（推荐）或 **Vitest**

**测试范围**：
- BehaviorEngine（行为推导公式）
- TriggerEngine（触发表执行）
- VisionManager（视野过滤）
- PromptBuilder（Prompt 构建）

---

### 6.2 集成测试（Phase 3）

**优先级**：P2

**需求**：
- 端到端测试（用户输入 → 角色回应）
- 验收标准自动化测试

---

## 七、文档与工具

### 7.1 开发文档（Phase 2）

**优先级**：P1

**需求**：
- API 文档（TypeDoc）
- 配置文件说明
- 开发指南

---

### 7.2 配置可视化工具（Phase 3）

**优先级**：P3

**需求**：
- 可视化编辑人物配置
- 可视化编辑触发表
- 可视化查看人物状态

---

### 7.3 Prompt 模板管理（Phase 2-3）

**优先级**：P1

**需求**：
- Phase 1 使用硬编码 Prompt，Phase 2-3 迁移到模板文件
- 支持模板变量替换
- 支持多语言 Prompt（可选）
- 模板版本管理

**实现方案**：
```typescript
// Phase 2-3 使用 Handlebars 模板引擎
import Handlebars from 'handlebars';

export class PromptTemplateManager {
  private templates: Map<string, HandlebarsTemplateDelegate> = new Map();

  constructor(private templateDir: string) {
    this.loadTemplates();
  }

  private loadTemplates(): void {
    // 从 prompts/ 目录加载所有 .hbs 文件
    const files = fs.readdirSync(this.templateDir);
    files.forEach(file => {
      if (file.endsWith('.hbs')) {
        const content = fs.readFileSync(path.join(this.templateDir, file), 'utf-8');
        const template = Handlebars.compile(content);
        this.templates.set(file.replace('.hbs', ''), template);
      }
    });
  }

  render(templateName: string, context: Record<string, any>): string {
    const template = this.templates.get(templateName);
    if (!template) {
      throw new Error(`Template not found: ${templateName}`);
    }
    return template(context);
  }
}
```

**模板示例**：
```handlebars
{{!-- prompts/character_response.hbs --}}
你是 {{characterName}}，性格特点：{{personality}}。

当前场景：{{sceneName}}
在场人物：{{#each presentCharacters}}{{this}}{{#unless @last}}、{{/unless}}{{/each}}

你已知的信息：
{{#each knownInfo}}
- {{this}}
{{/each}}

请根据以上信息，生成你的回应。
```

**目录结构**：
```
prompts/
├── character_response.hbs
├── character_action.hbs
├── scene_description.hbs
└── relationship_update.hbs
```

**迁移策略**：
- Phase 1：硬编码 Prompt（快速开发）
- Phase 2：迁移到 Handlebars 模板
- Phase 3：支持多语言模板（可选）

---

### 7.4 CI/CD 配置（Phase 2-3）

**优先级**：P1

**需求**：
- 自动化测试（单元测试、集成测试）
- 自动化构建
- 代码质量检查（ESLint、Prettier）
- 自动化发布（可选）

**实现方案**：
```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [20.x]

    steps:
      - uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Lint
        run: pnpm lint

      - name: Type check
        run: pnpm type-check

      - name: Test
        run: pnpm test

      - name: Build
        run: pnpm build

  coverage:
    runs-on: ubuntu-latest
    needs: test

    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v2
        with:
          version: 8
      - uses: actions/setup-node@v4
        with:
          node-version: 20.x
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Test with coverage
        run: pnpm test:coverage

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
```

**配置文件**：
- `.github/workflows/ci.yml`：CI 流程
- `.github/workflows/release.yml`：发布流程（Phase 3）

**检查项**：
- ESLint 检查通过
- Prettier 格式检查通过
- TypeScript 类型检查通过
- 单元测试通过（覆盖率 > 60%）
- 构建成功

---

## 八、优化项优先级总结

### Phase 2 必须实现（P0）

1. LLM 错误处理和重试机制
2. LLM 并发调用
3. 单元测试

### Phase 2 推荐实现（P1）

1. LLM 流式输出
2. 动态情绪状态
3. 动态动机强度
4. 数据库存储（可选，视人物数量而定）
5. 开发文档
6. Prompt 模板管理
7. CI/CD 配置

### Phase 3 实现（P2）

1. LLM 函数调用
2. 认知风格
3. LLM 响应缓存
4. 增量快照
5. 集成测试
6. 性能监控
7. 日志分析工具

### Phase 3 后可选（P3）

1. 行为演化与学习
2. 配置可视化工具

---

## 九、变更记录

| 版本 | 日期 | 变更内容 | 变更人 |
|------|------|----------|--------|
| v1.0 | 2026-02-05 | 初始版本，记录 Phase 2-3 优化项 | Claude Sonnet 4.5 |
| v1.1 | 2026-02-05 | 新增 Prompt 模板管理、CI/CD 配置、性能监控、日志分析工具 | Claude Sonnet 4.5 |

